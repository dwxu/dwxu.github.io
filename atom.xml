<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dongwu Xu</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.dwxu.me/"/>
  <updated>2018-06-19T10:03:05.318Z</updated>
  <id>http://www.dwxu.me/</id>
  
  <author>
    <name>Dongwu Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Cloud Config 配置中心项目实践</title>
    <link href="http://www.dwxu.me/2018/06/17/spring-cloud-config/"/>
    <id>http://www.dwxu.me/2018/06/17/spring-cloud-config/</id>
    <published>2018-06-17T04:02:24.000Z</published>
    <updated>2018-06-19T10:03:05.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、现状说明"><a href="#一、现状说明" class="headerlink" title="一、现状说明"></a>一、现状说明</h2><p>由于项目基于 Spring Cloud 微服务架构，将业务拆分多个服务/应用，出于高可用和负载均衡的考虑，每个服务会部署多个实例。每个服务实例都需要进行配置，配置又需要区分多种环境，简单区分如 dev(本地开发)/test(测试环境)/prod(生产环境)，每个实例至少也需要维护三份配置，如果由人工进行各个环境各个服务实例配置的部署和维护，随着实例数量的增加，配置文件分散在各个环境的各个目录下，那么运维工作量的会很大，也容易出错，出现相同服务的不同实例配置不一致的情况。<br>因此，考虑通过配置中心服务配置进行集中管理和维护，基于 Spring Cloud Config ，原则是部署环境应用零配置文件，由启动指令/脚本指定和加载不同环境的 profile。</p><h2 id="二、实践过程"><a href="#二、实践过程" class="headerlink" title="二、实践过程"></a>二、实践过程</h2><h3 id="1-新建-git-仓库并分配相关账号权限"><a href="#1-新建-git-仓库并分配相关账号权限" class="headerlink" title="1. 新建 git 仓库并分配相关账号权限"></a>1. 新建 git 仓库并分配相关账号权限</h3><ul><li>如 <a href="http://git.foo.com/bar/server-config-center" target="_blank" rel="noopener">http://git.foo.com/bar/server-config-center</a></li></ul><h3 id="2-配置中心服务模块（config-server）"><a href="#2-配置中心服务模块（config-server）" class="headerlink" title="2. 配置中心服务模块（config-server）"></a>2. 配置中心服务模块（config-server）</h3><h4 id="Maven-配置（pom-xml）"><a href="#Maven-配置（pom-xml）" class="headerlink" title="Maven 配置（pom.xml）"></a>Maven 配置（pom.xml）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="应用配置（application-yml）"><a href="#应用配置（application-yml）" class="headerlink" title="应用配置（application.yml）"></a>应用配置（application.yml）</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9800</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务注册中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">          defaultZone:</span> <span class="attr">http://$&#123;eureka.host:127.0.0.1&#125;:$&#123;eureka.port:8761&#125;/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">config-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line">          <span class="comment"># Git 仓库地址，注意需要加上 .git 的后缀</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">http://git.foo.com/bar/server-config-center.git</span> </span><br><span class="line">          <span class="comment"># 配置文件查找目录</span></span><br><span class="line"><span class="attr">          searchPaths:</span> <span class="string">baz-service</span></span><br><span class="line">          <span class="comment"># Git 账号</span></span><br><span class="line"><span class="attr">          username:</span> <span class="string">foo@foo.com</span></span><br><span class="line">          <span class="comment"># Git 密码</span></span><br><span class="line"><span class="attr">          password:</span> <span class="string">bar</span></span><br></pre></td></tr></table></figure><h4 id="启动类（-EnableConfigServer-开启配置服务）"><a href="#启动类（-EnableConfigServer-开启配置服务）" class="headerlink" title="启动类（@EnableConfigServer 开启配置服务）"></a>启动类（@EnableConfigServer 开启配置服务）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置读取验证："><a href="#配置读取验证：" class="headerlink" title="配置读取验证："></a>配置读取验证：</h4><ul><li>仓库下存在配置文件 baz-service/admin-service-dev.yml</li><li>访问 <a href="http://localhost:9800/admin-service/dev：" target="_blank" rel="noopener">http://localhost:9800/admin-service/dev：</a><br><img src="https://images.vrm.cn/2018/06/14/config-server.png" alt="config-server.png"></li></ul><h3 id="3-应用模块（以-admin-service-为例）"><a href="#3-应用模块（以-admin-service-为例）" class="headerlink" title="3 应用模块（以 admin-service 为例）"></a>3 应用模块（以 admin-service 为例）</h3><h4 id="添加依赖（pom-xml）"><a href="#添加依赖（pom-xml）" class="headerlink" title="添加依赖（pom.xml）"></a>添加依赖（pom.xml）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="应用配置（bootstrap-yml）"><a href="#应用配置（bootstrap-yml）" class="headerlink" title="应用配置（bootstrap.yml）"></a>应用配置（bootstrap.yml）</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">admin-service</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">      config:</span></span><br><span class="line"><span class="attr">        discovery:</span></span><br><span class="line">          <span class="comment"># 开启配置服务</span></span><br><span class="line"><span class="attr">          enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 配置服务ID，即 spring.application.name</span></span><br><span class="line"><span class="attr">          service-id:</span> <span class="string">config-server</span></span><br><span class="line">        <span class="comment"># 自定义多环境配置支持，如 dev、test、prod，默认为 dev</span></span><br><span class="line"><span class="attr">        profile:</span> <span class="string">$&#123;config.profile:dev&#125;</span></span><br><span class="line">        <span class="comment"># 配置仓库分支，默认为 master</span></span><br><span class="line"><span class="attr">        label:</span> <span class="string">$&#123;config.label:master&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务注册中心</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.host:127.0.0.1&#125;:$&#123;eureka.port:8761&#125;/eureka/</span></span><br></pre></td></tr></table></figure><h2 id="三、其他说明"><a href="#三、其他说明" class="headerlink" title="三、其他说明"></a>三、其他说明</h2><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h3><p>bootstrap.yml 在 application.yml 之前加载，用于应用程序上下文的引导阶段， 在这一阶段加载配置数据，因此需要将配置中心的配置写到该文件，而非 application.yml，否则会报错。</p><h3 id="2-配置变量（注意变量名不能与实际配置路径重复，如-spring-cloud-config-profile，否则会报错）"><a href="#2-配置变量（注意变量名不能与实际配置路径重复，如-spring-cloud-config-profile，否则会报错）" class="headerlink" title="2. 配置变量（注意变量名不能与实际配置路径重复，如 spring.cloud.config.profile，否则会报错）"></a>2. 配置变量（注意变量名不能与实际配置路径重复，如 spring.cloud.config.profile，否则会报错）</h3><ul><li>config.profile：指定环境配置文件，如 dev、test、prod</li><li>config.label：指定配置中心仓库分支</li></ul><h3 id="3-零配置文件实践"><a href="#3-零配置文件实践" class="headerlink" title="3. 零配置文件实践"></a>3. 零配置文件实践</h3><ul><li>bootstrap.yml （预留变量）配置打入 jar 包（classpath 路径下）；</li><li>约定好目录和文件命名规则，将应用、日志及自定义配置相关配置集中提交到 git 仓库，如 baz-service 项目的 admin-service 服务：<ul><li>本地开发环境：baz-service/admin-service-dev.yml</li><li>测试环境：baz-service/admin-service-test.yml</li><li>生产环境：baz-service/admin-service-prod.yml</li></ul></li><li>命令行启动指定 profile：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -Dconfig.profile=test -jar platform-service.jar &amp;</span><br></pre></td></tr></table></figure></li></ul><p>（以上命令行参数覆盖 spring.cloud.config.profile 的默认配置（dev），从配置中心获取 test 环境的配置。）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、现状说明&quot;&gt;&lt;a href=&quot;#一、现状说明&quot; class=&quot;headerlink&quot; title=&quot;一、现状说明&quot;&gt;&lt;/a&gt;一、现状说明&lt;/h2&gt;&lt;p&gt;由于项目基于 Spring Cloud 微服务架构，将业务拆分多个服务/应用，出于高可用和负载均衡的考虑，每
      
    
    </summary>
    
      <category term="解决方案，项目实践" scheme="http://www.dwxu.me/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%8C%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Spring-Cloud" scheme="http://www.dwxu.me/tags/Spring-Cloud/"/>
    
      <category term="Spring-Boot" scheme="http://www.dwxu.me/tags/Spring-Boot/"/>
    
      <category term="Spring-Cloud-Config" scheme="http://www.dwxu.me/tags/Spring-Cloud-Config/"/>
    
  </entry>
  
  <entry>
    <title>父亲节，难离难舍，总有一些</title>
    <link href="http://www.dwxu.me/2018/06/17/2018-father-day/"/>
    <id>http://www.dwxu.me/2018/06/17/2018-father-day/</id>
    <published>2018-06-16T17:22:11.000Z</published>
    <updated>2018-06-16T20:10:21.714Z</updated>
    
    <content type="html"><![CDATA[<p>印象中，父亲在我面前，哭过两次。</p><p><br></p><p>父亲第一次哭，是爷爷去世的时候，当时我还小，小到不知生死为何物，也没太大的感触和悲伤，只觉得那些天，家里来了很多人，爸爸妈妈和亲戚们忙里忙外的，现在回想起来，当时的气氛也不像在电视剧或者电影中那般沉重和伤情。只是，印象深刻的，是出葬的那一天，老爸哭了，红着眼，无声地擦拭着泪水。</p><p><br></p><p>爷爷也算高寿，活到九十岁左右。据说年轻时也是争强好胜、脾气火爆之人，然而也抵不过迟暮的凋零，他们那一代人经历的事情很多，生活贫苦、物质匮乏，身体多多少少都落下了一些隐患，中老年时总要经历一些病痛的折磨，爷爷也不例外，后来双目失明，完全失去视力，再后来排尿困难，常年需要治疗和借助外部仪器排尿。这些毛病，折磨了爷爷好多年，也折腾了父亲不知多长的时间，那些年，夜里总能听到，爷爷痛苦地呻吟和叫唤，还有，父亲的谩骂声。是的，父亲年轻的时候，脾气也火爆。</p><p><br></p><p>父亲的成长过程也比较坎坷。乡下地方，不仅重男轻女，家里也是长次有序，父亲是次子，在家中不受重视，要听人差遣，吃了不少苦，受了不少气，无可奈何。</p><p><br></p><p>印象中，始终没见过他们爷俩促膝长谈的场景，个中缘由，个中滋味，冷暖自知吧！</p><p><br></p><p>爷爷去世，这一天始终还是来了。那一阵子，父亲很忙，忙着扔掉所有爷爷起居的东西，忙着安排葬礼的事项，忙着招呼前来吊唁的亲朋好友，忙着守夜等待出葬的那一天。</p><p><br></p><p>也终于来到了一切都将结束的这一天，那天早上，父亲站在大堂，我看到他的眼眶明显红着、脸颊明显湿了。当时我和哥哥姐姐应该都看到这一场景，至于他们的感想，我也不得而知了。而我，内心受到了极大的触动。</p><p><br></p><p>是啊，爸爸，他的爸爸，那个把他带到世上、养育他、曾经他依赖的那个人去世，再也不会回来了。作为孩子，爸爸应该始终是自己的一座大山吧，而现在大山到了，那种深藏在记忆深处的安全感不在了，往后的一切都要依靠自己了。这种无助感和软弱，估计是每个失去父亲的孩子都会有的吧！</p><p><br></p><p>那段时间，我开始思考生死和父子关系，碍于年少和微乎其微的经历见闻、知识储备，带来的，是死亡/消失以及某天也会失去父亲的恐惧感。</p><p><br></p><p>父亲第二次哭，是自己当时青春叛逆，得理不饶人，父亲做错了事情，我把他数落和顶撞到哭了。现在想来，具体是什么事情已经遗忘，即使记得，估计也应该是小事一桩吧。当时父亲已步入中年，脾性有所改变，不再像年轻时那么暴躁了，否则我想，当时我要面对的，应该是一顿皮鞭的胖揍了。</p><p><br></p><p>印象深刻的，可能也是因为感悟深刻吧！是啊，老爸也是普通人，会做错事，也会因此受批评数落而感到委屈，甚至感到无助，自己犯错时又何尝不是呢？而当这种咄咄逼人来自自己的孩子时，情绪可能会更强烈一些吧！</p><p><br></p><p>和父亲单独相处的记忆不多，年轻时做一些买卖生意，他基本都是早出晚归的。</p><p><br></p><p>父亲读过高中，可以辅导我们小学和初中一些简单的数学知识，小的时候，也是因为在一旁看着父亲辅导哥哥而学得阿拉伯数字1-10的读写，惊艳到了当时小学的老师，得以提前一年入学读书。</p><p><br></p><p>小学的时候，父亲因肺部疾病入院，手术做完在医院休养的那段时间，母亲带着我们几个去探望父亲，尤其记得，当时第一次去病房探病，看着躺在病床神态虚弱的父亲，我们几个小孩，出奇安静乖巧的坐在旁边，不敢乱动乱说话，现在想来，估计可能是因为受电视影响，总觉得在医院会有不好的事情发生，让我们对眼前的一切感到不安和不确定。也值得庆幸的是，父亲也因此戒掉了抽烟的习惯。</p><p><br></p><p>中学的时候，因为腰部受伤，很严重，很长一段时间内需要每天去一次医院做治疗，不想休学，为了不影响学业，每天请假一节课去医院，父亲每天在约定的时间提前到学校门口等我下课后载我去做治疗。也是那段时间在医院的见闻，让我成长了不少，也更加体会到父亲的辛苦和不易。每天要预留带我看病的时间，风雨无阻。和老师沟通请假治疗的事情。为了不耽误上课，花了不少心思和红包，争取优先排队和治疗，起初我十分反感这样走后门的操作，他只是淡淡的回了我一句“这些你不用管”，而后我也不再提及这事了。也算幸运，后来恢复得不错。</p><p><br></p><p>高三住校备考，高考结束后，与其他同学的狂欢不同，我没有扔掉任何东西，只把一切都打包好，由于接送车辆太多了，父亲帮我一件一件地搬抬到远在校门之外的车上，回家的路上，我们父子相对无言，父亲也没有问我考得怎么样，估计也是怕给我增加负担，而自己又不善言辞，故而保持沉默。父亲的性格始终是内敛的，很少为我做任何决定，报考高中、填报大学都是我自己完成的，带我到校报名、确认好一切后他也就走了；高三的时候，自己觉得住校备考比较好，他也就想办法安排我入宿；当我自我感觉考试失利后，爸爸妈妈也只是询问我是否想复读，他们想办法安排而已。</p><p><br></p><p>最近一段时间经常听《单车》，越来越能理解和体会到歌词中“难舍难离，想抱紧些”对于父爱的眷恋与不舍，也才知道，作词人黄伟文也借这首歌在控诉深沉的父爱，在单车上有过的拥抱，是他唯一和爸爸觉得有亲近和爱的感觉。</p><p><br></p><p>为人父母，不需要经过各项考试，也没有教科书学习，我开始觉得这是人生中最难的一场修行，而不管如何，孩子总会长大，正如龙应台在《目送》中所说，“我慢慢地、慢慢地了解到，所谓父女母子一场，只不过意味着，你和他的缘分就是今生今世不断地在目送他的背影渐行渐远。你站在小路的这一端，看着他逐渐消失在小路转弯的地方，而且，他用背影默默告诉你：不必追。”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;印象中，父亲在我面前，哭过两次。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;父亲第一次哭，是爷爷去世的时候，当时我还小，小到不知生死为何物，也没太大的感触和悲伤，只觉得那些天，家里来了很多人，爸爸妈妈和亲戚们忙里忙外的，现在回想起来，当时的气氛也不像在电视剧或者电影中那般沉重和
      
    
    </summary>
    
      <category term="日记" scheme="http://www.dwxu.me/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="日记" scheme="http://www.dwxu.me/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据库复制（主从同步）延迟问题分析及处理过程</title>
    <link href="http://www.dwxu.me/2018/06/07/MariaDB-Replication-Delay/"/>
    <id>http://www.dwxu.me/2018/06/07/MariaDB-Replication-Delay/</id>
    <published>2018-06-07T15:43:27.000Z</published>
    <updated>2018-06-07T16:28:36.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>&emsp;&emsp;由于我们的产品数据量非常大，写库十分频繁，每日大概有 8 - 9 亿的数据写入数据库。使用中间件 Mycat 做分片管理 18 个数据库实例下的多个 DB，考虑减轻数据集中写入的压力，使用了主主同步/复制的模式。<br>&emsp;&emsp;随着时间的推移，数据库之间的同步延迟越来越大，导致从数据同步延迟的库中查询到的数据不实时，影响比较大，亟待解决。<br>&emsp;&emsp;我们实际使用的数据库为 MariaDB，MySQL 源代码的一个分支，大部分特性相同。<br><br></p><h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><h3 id="1-数据库同步-复制过程"><a href="#1-数据库同步-复制过程" class="headerlink" title="1. 数据库同步/复制过程"></a>1. 数据库同步/复制过程</h3><ul><li>Master 在每个事务更新数据完成之前，会在 Binlog 中记录这些改变，数据库将事务串行的写入二进制日志，即使事务中的语句都是交叉执行的。在事件写入二进制日志完成后，Master通知存储引擎提交事务;</li><li>Slave 的 I/O 线程将 Master 的 Binlog 拷贝到它自己的中继日志；</li><li>Slave 的 SQL Slave Thread 线程从中继日志读取事件，并重放其中的事件而更新slave的数据，使其与master中的数据一致，即完成同步。</li></ul><p>&emsp;&emsp;从以上过程可以看出，复制过程有一个很重要的限制，即复制在 Slave 上是串行化的，也就是说 Master 上的并行更新操作不能在 Slave 上并行操作。即使并发进行数据复制，线程数也是有限的。因此，事务在 Slave 上的执行效率没有 Master  那么高，这一点是无法避免的。</p><h3 id="2-数据库系统参数"><a href="#2-数据库系统参数" class="headerlink" title="2. 数据库系统参数"></a>2. 数据库系统参数</h3><ul><li>日志写入磁盘策略（InnoDB 引擎）：<ul><li>innodb_flush_log_at_trx_commit：日志写入/刷新策略；</li><li>sync_binlog：日志写入磁盘策略；</li></ul></li><li>同步/复制线程数：<ul><li>slave_parallel_threads</li></ul></li><li>组提交（MariaDB）：<ul><li>binlog_commit_wait_usec：延迟指定时间（毫秒）提交事务；</li><li>binlog_commit_wait_count：达到指定个数（事务）立即提交事务；</li></ul></li></ul><h3 id="3-程序层面"><a href="#3-程序层面" class="headerlink" title="3. 程序层面"></a>3. 程序层面</h3><ul><li>我们的程序数据入库周期为 10 分钟，期间使用内存做缓存和聚合；</li><li>不存在<strong>大事务</strong>（运行时间比较长，操作的数据比较多），实际上每次提交的事务仅包含一条SQL 语句，写入合并结果数据到数据库；</li><li>由于按数据库主键进行数据合并后再入库，锁冲突/竞争导致延迟过大的可能不大；</li></ul><h3 id="4-网络"><a href="#4-网络" class="headerlink" title="4. 网络"></a>4. 网络</h3><ul><li><p>当主从数据库服务器之间的带宽被占满、网络延迟很大的情况下，可能导致 Master 上的 Binlog 没有全量传输到 Slave，导致延迟；</p></li><li><p>线上排查发现 Slave 的  I/O 线程近乎实时地将 Master 的 Binlog 拷贝过来了，因此基本排除网络因素导致的延迟；</p></li></ul><h3 id="5-机器性能"><a href="#5-机器性能" class="headerlink" title="5. 机器性能"></a>5. 机器性能</h3><ul><li><p>主从数据库服务器差异：CPU/内存/磁盘等配置一致；</p></li><li><p>从数据库服务器负载：</p><ul><li>通过 top 指令分析系统运行各个进程的资源占用状况，没有明显的异常；</li><li>通过中间件 MyCat 分片管理，读写比较均匀地落到每个数据库实例上，不至于让某些实例负载过高；</li></ul></li><li><p>单独分析服务器 CPU、内存均无异常，分析磁盘：<br><img src="/2018/06/07/MariaDB-Replication-Delay/iostat.png" alt="iostat"><br>&emsp;&emsp;可以看出，sde 磁盘（多个数据库实例目录所在盘） I/O 十分频繁，100% 的时间都在进行读写操作，当 I/O 的响应跟不上数据库同步读写的需求时，即成为瓶颈。</p></li></ul><h2 id="三、处理过程"><a href="#三、处理过程" class="headerlink" title="三、处理过程"></a>三、处理过程</h2><h3 id="1-参数调优"><a href="#1-参数调优" class="headerlink" title="1. 参数调优"></a>1. 参数调优</h3><ul><li>innodb_flush_log_at_trx_commit 设置为 2 配合 sync_binlog 参数（100），每写入 100 次二进制日志后才将日志刷入磁盘，存在数据丢失可能（系统崩溃/断电）但写入性能较好；</li><li>slave_parallel_threads 配置为 16（需评估服务器硬件资源情况），即开启 16 个线程进行数据同步，提高复制并发度；</li><li>binlog_commit_wait_usec 设置为 100000（毫秒），binlog_commit_wait_count 设置为 20，接受一定程度的数据延迟；</li></ul><h3 id="2-程序优化"><a href="#2-程序优化" class="headerlink" title="2. 程序优化"></a>2. 程序优化</h3><ul><li>需要结合具体业务考虑优化方案，如数据缓存、批量入库等；</li></ul><h3 id="3-服务器性能提升"><a href="#3-服务器性能提升" class="headerlink" title="3. 服务器性能提升"></a>3. 服务器性能提升</h3><p>&emsp;&emsp;从上面的服务器性能分析中，我们怀疑磁盘可能是瓶颈（每秒I/O达100%）所在，因此做了如下操作进行验证：</p><ul><li>在其中一台运行了 5 个数据库实例的服务器上，逐一暂停实例运行，最终发现当降到只有 2 个实例同时运行时，磁盘 I/O 有明显下降，数据库的同步延迟在快速的追回，因此可以确定磁盘的 I/O 能力是瓶颈所在。因此我们在服务器上追加了几块性能比较好的磁盘（10K RPM），并将数据库实例迁移到不同盘上，减轻单个盘的 I/O 压力，Linux 系统下操作过程也不是特别复杂，以存放在 /data 目录下的 mysqld_1 迁移到挂载其他磁盘的 /data1 目录下为：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 暂停实例</span><br><span class="line">service mysqld_1 stop</span><br><span class="line"><span class="meta">#</span> 目录/数据拷贝，/data 挂载 sde 盘，/data1 挂载其他磁盘</span><br><span class="line">cp -a /data/mysql_1 /data1</span><br><span class="line"><span class="meta">#</span> 通过软链接的方式将 MariaDB 的实例目录指向迁移后的磁盘</span><br><span class="line">mv mysql_1 mysql_1.bak</span><br><span class="line">ln -s /data1/mysql_1 mysql_1</span><br><span class="line"><span class="meta">#</span> 重启实例，正常启动即完成了实例的迁移</span><br><span class="line">service mysqld_1 start</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;最终，磁盘 I/O 压力下降，数据库同步延迟在逐渐减少最终降到零（基本实时同步）：</p><p><img src="/2018/06/07/MariaDB-Replication-Delay/iostat1.png" alt="iostat"></p><p>&emsp;&emsp;因为一些原因，最终每台服务器只追加了两块磁盘（sdf 和 sdg ），可以看到，原来 100% 读写的 sde 盘的 %util （1 秒内 I/O 操作所占的比例）也降至 75%。可通过以下指令在数据库命令行下查看主从同步的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show slave status \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        ......</span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><h2 id="四、经验总结"><a href="#四、经验总结" class="headerlink" title="四、经验总结"></a>四、经验总结</h2><ul><li>大数据系统或数据量巨大的架构中，不适合在一台物理服务器上运行多个数据库实例，尤其都放到一块硬盘中，即使服务器总体性能很强，最终也只是造成部分资源的过剩和浪费，比如我们的服务器瓶颈在磁盘I/O，CPU 和 内存资源相对过剩，尤其是 CPU 90% 以上的时间处于空闲状态；</li><li>评估好数据库读写压力情况，慎用主主（互为主从关系）同步架构，存在循环同步判断和过滤开销；</li><li>排查问题时优先从 <strong>服务器资源</strong> 层面寻找瓶颈所在，进而分析 <strong>数据库系统</strong> 和 <strong>程序</strong> 层面的隐患所在和优化空间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;由于我们的产品数据量非常大，写库十分频繁，每日大概有 8 - 9 亿的数据写入数据库。使用中间件 M
      
    
    </summary>
    
      <category term="数据库" scheme="http://www.dwxu.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://www.dwxu.me/tags/MySQL/"/>
    
      <category term="MariaDB" scheme="http://www.dwxu.me/tags/MariaDB/"/>
    
      <category term="Replication" scheme="http://www.dwxu.me/tags/Replication/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 应用输出 Mybatis SQL 语句</title>
    <link href="http://www.dwxu.me/2018/05/31/spring-boot-mybatis-sql/"/>
    <id>http://www.dwxu.me/2018/05/31/spring-boot-mybatis-sql/</id>
    <published>2018-05-31T13:58:22.000Z</published>
    <updated>2018-05-31T14:04:52.708Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-在-logback-xml-增加配置"><a href="#1-在-logback-xml-增加配置" class="headerlink" title="1. 在 logback.xml 增加配置"></a>1. 在 logback.xml 增加配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输出到控制台 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;40&#125; - %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"stdout"</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.foo.component.mapper"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"stdout"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>logger 节点 name 属性的值为 Mybatis Mapper 接口所在包路径；</li><li>示例中将日志输出到标准输出（控制台）中；</li></ul><h4 id="2-重启应用"><a href="#2-重启应用" class="headerlink" title="2. 重启应用"></a>2. 重启应用</h4><h4 id="3-进行数据库查询，可以看到控制台输出相关-SQL-查询日志"><a href="#3-进行数据库查询，可以看到控制台输出相关-SQL-查询日志" class="headerlink" title="3. 进行数据库查询，可以看到控制台输出相关 SQL 查询日志"></a>3. 进行数据库查询，可以看到控制台输出相关 SQL 查询日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">09:07:58.029 [http-nio-8030-exec-1] DEBUG l._.p.c.mapper.UserSiteMapper.count - ==&gt;  Preparing: select count(id) from platform_user_site WHERE user_id = ? </span><br><span class="line">09:07:58.029 [http-nio-8030-exec-1] DEBUG l._.p.c.mapper.UserSiteMapper.count - ==&gt; Parameters: 3(Long)</span><br><span class="line">09:07:58.032 [http-nio-8030-exec-1] DEBUG l._.p.c.mapper.UserSiteMapper.count - &lt;==      Total: 1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-在-logback-xml-增加配置&quot;&gt;&lt;a href=&quot;#1-在-logback-xml-增加配置&quot; class=&quot;headerlink&quot; title=&quot;1. 在 logback.xml 增加配置&quot;&gt;&lt;/a&gt;1. 在 logback.xml 增加配置&lt;/h4
      
    
    </summary>
    
      <category term="Spring" scheme="http://www.dwxu.me/categories/Spring/"/>
    
    
      <category term="Spring-Boot" scheme="http://www.dwxu.me/tags/Spring-Boot/"/>
    
      <category term="Mybatis" scheme="http://www.dwxu.me/tags/Mybatis/"/>
    
      <category term="Logback" scheme="http://www.dwxu.me/tags/Logback/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 多服务/多实例 Session 共享</title>
    <link href="http://www.dwxu.me/2018/05/29/spring-cloud-session/"/>
    <id>http://www.dwxu.me/2018/05/29/spring-cloud-session/</id>
    <published>2018-05-29T14:50:16.000Z</published>
    <updated>2018-05-29T16:06:11.551Z</updated>
    
    <content type="html"><![CDATA[<p>项目中，前后端分离，后端使用 Spring Cloud 管理多个微服务和多个实例，使用 Zuul 实现 API Gateway （反向代理）供前端请求/访问。<br><br><br>前后端分离，需要做前端请求的权限认证，即鉴权，由于我们的项目后端提供的接口仅供前端请求，非对外公共接口，因此不考虑搭建统一认证（如 OAUTH 2.0）中心走那么复杂的认证过程，此外考虑过做简单  JWT 的认证，但由于缺点比较明显，如注销/退出问题，在 JWT 过期之前无法/难以作废已颁发的令牌，最后决定用回简单的 Http Session 认证/验证，用户注销/退出时清除 Session 中记录的用户/权限信息，关闭浏览器后 Session 自动失效。<br><br><br>那么需要解决的问题，是 <strong>多服务</strong> 或者 <strong>服务多实例</strong> 间的 Session 共享问题，Spring 本身提供了 Spring-session 方案和策略（常用为 Cookie 和 Header 方式），配合 Redis 即可实现 Session 的共享：</p><ul><li><p>应用 pom.xml 引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;redis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-session.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>应用 application.yml 添加 Redis 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 192.168.1.221</span><br><span class="line">    port: 6379</span><br><span class="line">    password: password</span><br></pre></td></tr></table></figure></li><li><p>应用 Session 配置（代码），使用 Cookie 方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableRedisHttpSession</span>(redisFlushMode = RedisFlushMode.IMMEDIATE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSessionConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpSessionStrategy <span class="title">httpSessionStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CookieHttpSessionStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br><br>然而存在问题，前端请求经过 API Gateway，Zuul 没有把原始请求的 Cookie（Header）转发到服务（应用），因此应用每次获取的 Session 都不一样（每次都生成新的 Session）。因此需要在 API Gateway （Zuul）这一层增加处理：</p><ul><li>按上述过程在 API Gateway 应用中开启 Session 共享；</li><li>实现一个 ZuulFilter 过滤器，将 Cookie（因为我们使用的是 Cookie 共享策略）写入转发的请求头部中：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardCookieFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        HttpSession httpSession = context.getRequest().getSession();</span><br><span class="line">        context.addZuulRequestHeader(<span class="string">"Cookie"</span>, <span class="string">"SESSION="</span> + httpSession.getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br><br>请求到达服务/应用时，Spring-session 共享即可生效，简单测试：</p><ul><li><p>在 Controller 中读写 Session（Attribute）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"foo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(request.getSession().getId());</span><br><span class="line">        request.getSession().setAttribute(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"bar"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(request.getSession().getId());</span><br><span class="line">        System.out.println(<span class="string">"foo: "</span> + request.getSession().getAttribute(<span class="string">"foo"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>部署两个实例：</p><div align="center"><br><img src="/2018/05/29/spring-cloud-session/instances.png" alt="iostat"><br></div></li><li>访问 /foo，其中一个实例会将 “bar” 写入 Session 的 “foo” 属性中；</li><li>多次访问 /bar，可以看到两个实例控制台交替输出中，sessionId 保持不变，正确输出写入的  Session 属性值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3f4fa81c-ecb4-41b4-a551-daab0f3198aa</span><br><span class="line">foo: bar</span><br></pre></td></tr></table></figure></li></ul><p><br><br>另外，网上有其他处理的方法，如修改 Zuul 和 Hystrix 的配置，没有实际验证过，不知是否有效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目中，前后端分离，后端使用 Spring Cloud 管理多个微服务和多个实例，使用 Zuul 实现 API Gateway （反向代理）供前端请求/访问。&lt;br&gt;&lt;br&gt;&lt;br&gt;前后端分离，需要做前端请求的权限认证，即鉴权，由于我们的项目后端提供的接口仅供前端请求，非对
      
    
    </summary>
    
      <category term="Spring" scheme="http://www.dwxu.me/categories/Spring/"/>
    
    
      <category term="Redis" scheme="http://www.dwxu.me/tags/Redis/"/>
    
      <category term="Spring-Cloud" scheme="http://www.dwxu.me/tags/Spring-Cloud/"/>
    
      <category term="Spring-Session" scheme="http://www.dwxu.me/tags/Spring-Session/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统端口范围限制</title>
    <link href="http://www.dwxu.me/2018/05/27/linux-port/"/>
    <id>http://www.dwxu.me/2018/05/27/linux-port/</id>
    <published>2018-05-27T01:36:19.000Z</published>
    <updated>2018-05-27T02:35:41.206Z</updated>
    
    <content type="html"><![CDATA[<p>最近参与的项目中，使用 Apche Storm 实时消费/处理 Kafka 消息，但提交执行 Topology 时，经常发现启动（各个工作节点正常工作）很久，查看工作节点的相关日志（${STORM_HOME}/logs/workers-artifacts/ 目录下），经常发现有大量以下错误日志在滚动输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-05-24 15:30:00.453 o.a.s.m.n.Client [ERROR] connection attempt 26 to Netty-Client-cdh5/xxx.xxx.xxx.xxx:6714 failed: java.net.ConnectException: Connection refused: cdh5/xxx.xxx.xxx.xxx:6714</span><br></pre></td></tr></table></figure></p><p>从日志初步看，是工作进程尝试与其他工作进程进行通信建立连接时被拒绝，很大可能是工作进程还没有启动完成（监听相关端口，如上述日志中 cdh5 的 6714 端口）。<br><br><br>正常来说，程序监听空闲端口启动是很快的，除非是端口被占用了，一直在等待端口释放。我们的 Storm 集群中有多个工作节点共一个百多工作进程（worker），其中某些节点上的某些工作进程监听端口失败一直在重试，节点工作进程间通信失败，整个集群启动耗时很长甚至无法完成启动进行工作。<br><br><br>我们 Storm 的工作进程端口列表（${STORM_HOME}/conf/storm.yaml 配置 supervisor.slots.ports 指定）为  6700 - 6731，查看 Linux 系统预留源端口：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat /proc/sys/net/ipv4/ip_local_port_range</span><br><span class="line">1024 65000</span><br></pre></td></tr></table></figure></p><p><br><br>系统预留了 1024 - 65000 端口作为服务端口，也就是说 TCP/IP协议栈会从 1024 - 65000 中随机选取端口作为源与其他服务建立连接进行通信，而我们 Strom 的工作进程端口列表正好包含在这个范围内，但程序停止时，释放的端口可能被占用了，导致下次启动异常，因此需要调整该配置：</p><ul><li>修改 /etc/sysctl.conf 中 net.ipv4.ip_local_port_range 配置的范围，使其不包含我们需要的 6700 - 6731（如 6732 - 65000）；</li><li>重启系统或者执行 <strong>sysctl -p</strong> 让配置生效；</li><li>注意端口范围不要超过 1024 和 65535，1024 以下系统使用，65535 以上设置会会提示失败；</li></ul><p><br><br>经过以上的操作，我们再次向 Strom 集群提交 Topology 后启动便很快了，另外从 Storm UI 监控界面上也发现消费速度有很大的提升（估计也跟端口开放/竞争有关）。</p><p>另外，ip_local_port_range 是范围配置，以上修改使得系统可用端口量减少了，但服务器需要消耗大量端口号时可能会存在瓶颈。可与以下配置配合：</p><ul><li>ip_local_reserved_ports：TCP/IP协议栈从 ip_local_port_range 中随机选取源端口时，会排除ip_local_reserved_ports 中定义的端口，同样在 /etc/sysctl.conf 中配置；</li></ul><p>如以上修改按以下配置（不改动 ip_local_port_range ）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_local_reserved_ports = 6700-6731</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> sysctl -p</span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">kernel.sysrq = 0</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line">net.ipv4.ip_local_reserved_ports = 6700-6731</span><br><span class="line"><span class="meta">#</span> cat /proc/sys/net/ipv4/ip_local_port_range</span><br><span class="line">1024 65000</span><br><span class="line"><span class="meta">#</span> cat /proc/sys/net/ipv4/ip_local_reserved_ports</span><br><span class="line">6700-6731</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近参与的项目中，使用 Apche Storm 实时消费/处理 Kafka 消息，但提交执行 Topology 时，经常发现启动（各个工作节点正常工作）很久，查看工作节点的相关日志（${STORM_HOME}/logs/workers-artifacts/ 目录下），经常发
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.dwxu.me/categories/Linux/"/>
    
    
      <category term="运维" scheme="http://www.dwxu.me/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统使用 iostat 命令监视磁盘设备活动情况</title>
    <link href="http://www.dwxu.me/2018/05/24/linux-iostat/"/>
    <id>http://www.dwxu.me/2018/05/24/linux-iostat/</id>
    <published>2018-05-24T14:10:10.000Z</published>
    <updated>2018-05-27T02:35:09.960Z</updated>
    
    <content type="html"><![CDATA[<p>最近在排查 MariaDB 主从数据库数据同步/复制延迟问题，使用 Linux 系统的 iostat 查看服务器磁盘设备的活动情况，发现瓶颈在于磁盘的I/O，一般而言，大量数据读写频繁的情况下，最终磁盘I/O都会成为瓶颈。</p><h3 id="1-使用说明"><a href="#1-使用说明" class="headerlink" title="1. 使用说明"></a>1. 使用说明</h3><ul><li>查看 CPU 和磁盘 I/O 相关的统计信息</li><li><p>指令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[51la_dev@db2 ~]$ iostat --help</span><br><span class="line">Usage: iostat [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]</span><br><span class="line">Options are:</span><br><span class="line">[ -c ] [ -d ] [ -N ] [ -n ] [ -h ] [ -k | -m ] [ -t ] [ -V ] [ -x ] [ -y ] [ -z ]</span><br><span class="line">[ -j &#123; ID | LABEL | PATH | UUID | ... &#125; [ &lt;device&gt; [...] | ALL ] ]</span><br><span class="line">[ &lt;device&gt; [...] | ALL ] [ -p [ &lt;device&gt; [,...] | ALL ] ]</span><br></pre></td></tr></table></figure></li><li><p>主要参数说明：</p><ul><li>-c：显示CPU使用情况</li><li>-d：显示磁盘使用情况</li><li>-k：以 KB 为单位显示</li><li>-m：以 M 为单位显示</li><li>-N：显示磁盘阵列(LVM) 信息</li><li>-n：显示NFS 使用情况</li><li>-p[磁盘]：显示磁盘和分区的情况</li><li>-t：显示终端和CPU的信息</li><li>-x：显示详细信息</li><li>-V：显示版本信息</li></ul></li></ul><h3 id="2-使用实例"><a href="#2-使用实例" class="headerlink" title="2. 使用实例"></a>2. 使用实例</h3><p><div align="center"><br><img src="/2018/05/24/linux-iostat/iostat.png" alt="iostat"><br></div></p><ul><li><p>输出信息说明：</p><ul><li>首行：系统/服务器相关信息</li><li>avg-cpu：cpu 状态信息</li><li>rrqm/s：每秒合并读操作的次数</li><li>wrqm/s：每秒合并写操作的次数</li><li>r/s：每秒读操作的次数</li><li>w/s： 每秒写操作的次数</li><li>rMB/s：每秒读取的MB字节数</li><li>wMB/s：每秒写入的MB字节数</li><li>avgrq-sz：平均每个 I/O 操作的扇区数，即所有请求的平均大小，以扇区（512字节）为单位</li><li>avgqu-sz：平均 I/O 请求队列长度</li><li>await：平均每个 I/O 所需要的时间，包括在队列等待的时间，也包括磁盘控制器处理本次请求的有效时间（毫秒）</li><li>r_wait：每个读操作平均所需要的时间，不仅包括硬盘设备读操作的时间，也包括在内核队列中的时间（毫秒）</li><li>w_wait：每个写操平均所需要的时间，不仅包括硬盘设备写操作的时间，也包括在队列中等待的时间（毫秒）</li><li>svctm：平均每次设备I/O操作的服务时间 (毫秒)</li><li>%util：工作时间或者繁忙时间占总时间的百分比</li></ul></li><li><p>简单分析以上截图：</p><ul><li>服务器有 48 个逻辑 CPU，而且很空闲（93.36% 的空闲），性能是比较强</li><li>sde 磁盘/设备的写操作十分频繁（每秒超过 1000 次），读操作平均等待时间超过 1000 毫秒，尤其是 %util 到达 100%（没有空闲时间），很容易（或已经）导致性能受限，成为相关任务的瓶颈。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在排查 MariaDB 主从数据库数据同步/复制延迟问题，使用 Linux 系统的 iostat 查看服务器磁盘设备的活动情况，发现瓶颈在于磁盘的I/O，一般而言，大量数据读写频繁的情况下，最终磁盘I/O都会成为瓶颈。&lt;/p&gt;
&lt;h3 id=&quot;1-使用说明&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.dwxu.me/categories/Linux/"/>
    
    
      <category term="运维" scheme="http://www.dwxu.me/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Java自动装箱和拆箱</title>
    <link href="http://www.dwxu.me/2018/05/22/java-boxing/"/>
    <id>http://www.dwxu.me/2018/05/22/java-boxing/</id>
    <published>2018-05-22T14:10:15.000Z</published>
    <updated>2018-05-22T14:47:11.607Z</updated>
    
    <content type="html"><![CDATA[<p>毫无疑问，自动装箱和自动拆箱是 Java 语言里使用最多的语法糖。以 Integer 为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer foo = <span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt; bar = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    Integer[] baz = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为 Class 文件后反编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">    Integer var1 = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    List var2 = Arrays.asList(Integer.valueOf(<span class="number">1</span>), Integer.valueOf(<span class="number">2</span>), Integer.valueOf(<span class="number">3</span>), Integer.valueOf(<span class="number">4</span>));</span><br><span class="line">    Integer[] var10000 = <span class="keyword">new</span> Integer[]&#123;Integer.valueOf(<span class="number">1</span>), Integer.valueOf(<span class="number">2</span>), Integer.valueOf(<span class="number">3</span>), Integer.valueOf(<span class="number">4</span>)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br>自动装箱和拆箱是 JDK1.5 的新特性，之前都是手动进行包装类的装箱和拆箱：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> foo = <span class="number">1</span>; <span class="comment">// 基本数据类型int</span></span><br><span class="line">Integer bar = <span class="keyword">new</span> Integer(foo); <span class="comment">// 手动装箱</span></span><br><span class="line"><span class="keyword">int</span> baz = bar.intValue(); <span class="comment">// 手动拆箱</span></span><br></pre></td></tr></table></figure></p><p>JDK1.5 之后自动进行装箱和拆箱：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer foo = <span class="number">10</span>; <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">int</span> bar = foo; <span class="comment">// 自动拆箱</span></span><br><span class="line">System.out.println(foo--); <span class="comment">// 输出10, 计算时的自动拆箱</span></span><br></pre></td></tr></table></figure></p><p><br><br>另外，观察以下程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">95</span>;</span><br><span class="line">    Integer b = <span class="number">95</span>;</span><br><span class="line">    System.out.println(<span class="string">"a == b: "</span> + (a == b));</span><br><span class="line"></span><br><span class="line">    Integer c = <span class="number">295</span>;</span><br><span class="line">    Integer d = <span class="number">295</span>;</span><br><span class="line">    System.out.println(<span class="string">"c == d: "</span> + (c == d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a == b: <span class="keyword">true</span></span><br><span class="line">c == d: <span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><p>原因是在自动装箱的时候，[-128, 127] 内的值被装箱成 Integer 对象存在内存中（Cache），可以被重用，“ == ” 比较的是对象的内存地址，因此 a 和 b 实际上是同一个对象，比较结果自然是 true，而超出以上范围的数值装箱后的对象并不会被重用，那么就相当于创建两个对象，比较的结果自然是false。<br><br><br>每种基本数据类型都有对应的包装类，如下：</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;毫无疑问，自动装箱和自动拆箱是 Java 语言里使用最多的语法糖。以 Integer 为例：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://www.dwxu.me/categories/Java/"/>
    
    
      <category term="语法糖" scheme="http://www.dwxu.me/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
  </entry>
  
  <entry>
    <title>同一手机号注册多个 Gmail 邮箱</title>
    <link href="http://www.dwxu.me/2018/05/21/gmail-register/"/>
    <id>http://www.dwxu.me/2018/05/21/gmail-register/</id>
    <published>2018-05-21T13:37:18.000Z</published>
    <updated>2018-05-24T14:54:28.964Z</updated>
    
    <content type="html"><![CDATA[<p>由于之前注册的 Gmail 邮箱地址包含个人信息（十分建议申请邮箱地址时慎用个人信息，如生日等）并且不太正式，因此想另外申请一个邮箱地址，然而目前一个手机号注册只能注册一个账号，无法直接重新申请：<br><img src="/2018/05/21/gmail-register/gmail1.png" alt="提示号码无法用于进行验证"><br><br><br>尝试了多种方式进行注册后，发现可以使用 <strong>Chrome 浏览器</strong> 注册成功：</p><ul><li><p>打开 <strong>设置</strong> 页面，点击 <strong>登录 CHROME</strong>，在弹出来的对话框中，点击 <strong>更多选项</strong>，选择 <strong>创建新账号</strong>：<br><img src="/2018/05/21/gmail-register/gmail2.png" alt="提示号码无法用于进行验证"></p></li><li><p>按提示填写 <strong>姓氏</strong> 和 <strong>姓名</strong> 后，进入发送验证码页面，<strong>国家/地区</strong> 选择 <strong>HK</strong>，电话号码前面增加 <strong>+86</strong>：<br><img src="/2018/05/21/gmail-register/gmail3.png" alt="提示号码无法用于进行验证"></p></li><li><p>点击 <strong>下一步</strong>，即可收到验证码短信：<br><img src="/2018/05/21/gmail-register/gmail4.jpeg" alt="提示号码无法用于进行验证"></p></li><li><p>之后根据提示填写邮箱地址完成注册<br><br></p></li></ul><p>旧的邮箱可能绑定过其他网站或者系统，也需要查看相关邮件，可以使用新的邮箱代收旧邮箱的邮件，在 Gmail 邮箱界面 设置 - 账号和导入 - 查收其他账号的邮件 中进行设置，具体操作可点击 <a href="https://support.google.com/mail/answer/21289?hl=zh-Hans" target="_blank" rel="noopener">了解详情</a> 查看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于之前注册的 Gmail 邮箱地址包含个人信息（十分建议申请邮箱地址时慎用个人信息，如生日等）并且不太正式，因此想另外申请一个邮箱地址，然而目前一个手机号注册只能注册一个账号，无法直接重新申请：&lt;br&gt;&lt;img src=&quot;/2018/05/21/gmail-registe
      
    
    </summary>
    
      <category term="备忘" scheme="http://www.dwxu.me/categories/%E5%A4%87%E5%BF%98/"/>
    
    
      <category term="Gmail" scheme="http://www.dwxu.me/tags/Gmail/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型与类型擦除</title>
    <link href="http://www.dwxu.me/2018/05/19/java-generics/"/>
    <id>http://www.dwxu.me/2018/05/19/java-generics/</id>
    <published>2018-05-19T09:26:40.000Z</published>
    <updated>2018-05-22T14:46:07.196Z</updated>
    
    <content type="html"><![CDATA[<p>泛型是 JDK1.5 的一项新增特性，本质是参数化类型的应用，即所操作的数据类型被指定为一个参数，可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法：</p><ul><li><p>泛型接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过类实现泛型接口时指定泛型 K 和 V 的具体类型，如 java.util 包中的 Map&lt;K, V&gt; ；</span><br></pre></td></tr></table></figure></li><li><p>泛型类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译器无法知道 K 和 V 的具体类型，只有运行时才真正根据类型来构造和分配内存，如 java.util 包中的 HashMap&lt;K,V&gt; ；</span><br></pre></td></tr></table></figure></li><li><p>泛型方法：泛型方法返回值前加一个<k>、<v>等来声明这是一个泛型方法，如</v></k></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><p>实际上，Java中 的泛型与 C++/C# 的中泛型实现不同，只在程序源码中存在，在编译后的字节码文件中，就已经替换为原生类型（也称为裸类型，如 Map&lt;K, V&gt; 即为 Map），并且在相应的地方插入了强制类型转换的代码，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Map&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">data.put(<span class="string">"foo"</span>, <span class="string">"foo"</span>);</span><br><span class="line">data.put(<span class="string">"bar"</span>, <span class="string">"bar"</span>);</span><br><span class="line">data.put(<span class="string">"baz"</span>, <span class="string">"baz"</span>);</span><br><span class="line">System.out.println(data.get(<span class="string">"foo"</span>));</span><br><span class="line">System.out.println(data.get(<span class="string">"bar"</span>));</span><br><span class="line">System.out.println(data.get(<span class="string">"baz"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为 Class 文件后反编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span> </span>&#123;</span><br><span class="line">    HashMap localHashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    localHashMap.put(<span class="string">"foo"</span>, <span class="string">"foo"</span>);</span><br><span class="line">    localHashMap.put(<span class="string">"bar"</span>, <span class="string">"bar"</span>);</span><br><span class="line">    localHashMap.put(<span class="string">"baz"</span>, <span class="string">"baz"</span>);</span><br><span class="line">    System.out.println((String)localHashMap.get(<span class="string">"foo"</span>));</span><br><span class="line">    System.out.println((String)localHashMap.get(<span class="string">"bar"</span>));</span><br><span class="line">    System.out.println((String)localHashMap.get(<span class="string">"baz"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><p>这种类型擦除的方式实现的泛型支持，只是作为一种语法糖来方便程序员的代码开发，提高效率和语法的严谨性，减少编码出错的机会，但并没有提供底层实质性的功能改进，因此 Java 的泛型支持实现一直存在争议和批评，例如由于 List&lt;String&gt; 和 List&lt;Integer&gt; 擦除后是同一类型（List），无法实现重载（实际上，两个方法如果返回值类型不同，使用 Sun JDK 1.6 的 javac 也能编译成功）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;泛型是 JDK1.5 的一项新增特性，本质是参数化类型的应用，即所操作的数据类型被指定为一个参数，可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;泛型接口：&lt;/p&gt;
&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
      <category term="Java" scheme="http://www.dwxu.me/categories/Java/"/>
    
    
      <category term="语法糖" scheme="http://www.dwxu.me/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
      <category term="泛型" scheme="http://www.dwxu.me/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>高并发下多站点在线访问实时统计</title>
    <link href="http://www.dwxu.me/2018/05/16/online-statistics/"/>
    <id>http://www.dwxu.me/2018/05/16/online-statistics/</id>
    <published>2018-05-16T15:20:09.000Z</published>
    <updated>2018-05-16T15:24:15.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、业务背景"><a href="#一、业务背景" class="headerlink" title="一、业务背景"></a>一、业务背景</h3><ul><li>实时统计多个站点的在线独立访问情况；</li><li>统计的时间范围为 10/15/30 分钟；</li><li>所有站点每秒累计约 10w 的 pv；</li></ul><h3 id="二、解决思路"><a href="#二、解决思路" class="headerlink" title="二、解决思路"></a>二、解决思路</h3><ul><li>按客户端 IP+SessionId 区分独立访问；</li><li>将在线访问信息（站点ID、IP、Session Id、访问时间等）写入 Kafka 集群；</li><li>Storm(集群) 实时消费 Kafka 在线访问信息/消息，合并访问写入 Redis；</li><li>上层应用从 Redis 获取各站点 10/15/30 分钟内的独立访问数据进行计算并展示；</li></ul><h3 id="三、详细设计"><a href="#三、详细设计" class="headerlink" title="三、详细设计"></a>三、详细设计</h3><h4 id="1-redis-数据结构设计"><a href="#1-redis-数据结构设计" class="headerlink" title="1. redis 数据结构设计"></a>1. redis 数据结构设计</h4><ul><li>将每分钟的站点数据写入一个 Hash 集合（过期时间为 30 分钟），key 为 online:{comId}:{minute}，其中 {comId} 为站点ID，{minute} 为在线时间的分钟字段（0-59）；</li><li>集合下的元素结构为：field - {ip}:{sessionId}（独立访问），value - 该独立访问一分钟内的请求/响应次数，通过 hincrby 指令递增；</li></ul><h4 id="2-数据统计"><a href="#2-数据统计" class="headerlink" title="2. 数据统计"></a>2. 数据统计</h4><ul><li>统计范围为当前 10/15/30 分钟内；</li><li>通过站点ID及当前时间从 redis 中读取该站点 30 分钟内的数据集合，例如站点ID为1，查询时间为 9点33分钟，则从 redis 读取 online:1:33 - online:1:3 的数据集合；</li><li>合并数据集合的 key（{ip}:{sessionId}），即去重，即可得到指定时间范围内的在线访问数；</li></ul><h4 id="3-说明"><a href="#3-说明" class="headerlink" title="3. 说明"></a>3. 说明</h4><ul><li>数据写入 Redis 频繁，需要优先考虑写入耗时和内存的问题，因此通过 hincrby 和 expired 这两个时间复杂度为 O(1) 的指令来快速写入在线数据；</li><li>每个站点的数据集合过期时间为 30 分钟（根据请求时间计算过期的时间戳），因此一个站点最多同时存在 30 个数据集合，过期的集合由 Redis 自动清理，无需再自行清理；</li><li>每个集合的有效数据实际为 field 的部分，记录每分钟的独立访问，接口在获取数据进行统计时，直接取出 field 的 Set 集合进行自动合并即可；</li></ul><h3 id="四、线上情况"><a href="#四、线上情况" class="headerlink" title="四、线上情况"></a>四、线上情况</h3><ul><li>Redis 单机/单实例；</li><li>30分钟内活跃的站点约 1.5w 个，两个小时内监控 Redis，redis 总内存占用稳定在 5.5G 以下（较上线此统计前多占用 1G 内存），数据集合能够正常过期并被 redis 清理；</li><li>应用 0.3s 内完成统计访问最频繁/数据量最大的站点的各时段内在线访问情况，当然跟服务器性能比较好也有关系；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、业务背景&quot;&gt;&lt;a href=&quot;#一、业务背景&quot; class=&quot;headerlink&quot; title=&quot;一、业务背景&quot;&gt;&lt;/a&gt;一、业务背景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;实时统计多个站点的在线独立访问情况；&lt;/li&gt;
&lt;li&gt;统计的时间范围为 10/15/30 分钟
      
    
    </summary>
    
      <category term="解决方案" scheme="http://www.dwxu.me/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="实时统计" scheme="http://www.dwxu.me/tags/%E5%AE%9E%E6%97%B6%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="Redis" scheme="http://www.dwxu.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>各大搜索引擎来路referer头部及搜索关键字字段</title>
    <link href="http://www.dwxu.me/2018/05/15/search-engine-referer/"/>
    <id>http://www.dwxu.me/2018/05/15/search-engine-referer/</id>
    <published>2018-05-15T12:25:00.000Z</published>
    <updated>2018-05-15T12:38:28.993Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-百度搜索："><a href="#1-百度搜索：" class="headerlink" title="1. 百度搜索："></a>1. 百度搜索：</h4><ul><li><p>PC端：</p><ul><li><p>referer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/link?url=gZRk-i0rKd2zEpXr6gLWgcMaB6gj49Qh0SRhVyeD1TG&amp;wd=&amp;eqid=e0224cf50000f590000000065ac98dee</span><br></pre></td></tr></table></figure></li><li><p>关键字字段：wd（无实际值）</p></li></ul></li><li><p>移动端：</p><ul><li><p>referer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://m.baidu.com/from=0/bd_page_type=1/ssid=0/uid=0/pu=usm%401%2Csz%40320_1001%2Cta%40iphone_2_6.0_3_537/baiduid=EDC0F469B2C8C28ED6153A8DFE7B0F35/w=0_10_/t=iphone/l=1/tc?ref=www_iphone&amp;lid=9293408228010889187&amp;order=1&amp;fm=alop&amp;dict=-1&amp;tj=www_sitelink_normal_1_0_10_title&amp;wd=&amp;eqid=80f8d18b77481000100000005ac98e54&amp;w_qd=IlPT2AEptyoA_yjkTUugn4fHR5kW&amp;tcplug=1&amp;sec=28899&amp;di=6b8e30a65323dcbb&amp;bdenc=1&amp;tch=124.0.206.178.0.0&amp;nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IEQGG_8kJLDKv7JuV&amp;clk_info=%7B%22srcid%22%3A1539%2C%22tplname%22%3A%22www_sitelink_normal%22%2C%22t%22%3A1523158616510%2C%22xpath%22%3A%22div-a-h3-em%22%7D</span><br></pre></td></tr></table></figure></li><li><p>关键字字段：wd（无实际值）</p></li></ul></li></ul><h4 id="2-搜狗搜索（soso-搜索）："><a href="#2-搜狗搜索（soso-搜索）：" class="headerlink" title="2. 搜狗搜索（soso 搜索）："></a>2. 搜狗搜索（soso 搜索）：</h4><ul><li><p>PC端：</p><ul><li><p>referer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.sogou.com/link?url=DSOYnZeCC_oowgX7OeX6FW4YafSeot-j</span><br></pre></td></tr></table></figure></li><li><p>关键字字段：无</p></li></ul></li><li><p>移动端：</p><ul><li><p>referer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://m.sogou.com/web/searchList.jsp?uID=vU0WMAQthy-ORLar&amp;v=5&amp;from=index&amp;w=1274&amp;t=1523158841365&amp;s_t=1523158844479&amp;s_from=index&amp;keyword=51la%E7%BB%9F%E8%AE%A1&amp;pg=webSearchList&amp;sourceid=sugg&amp;sugoq=&amp;sugn=0&amp;suguuid=fa153a85-07bb-4afa-bb07-69d3775d9966&amp;sugsuv=AAHV9fA6HwAAAAqRK1G8bQ0A1wA%3D&amp;sugtime=1523158844484</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://wap.sogou.com/web/searchList.jsp?uID=vU0WMAQthy-ORLar&amp;v=5&amp;from=index&amp;w=1274&amp;t=1523158841365&amp;s_t=1523158844479&amp;s_from=index&amp;keyword=51la%E7%BB%9F%E8%AE%A1&amp;pg=webSearchList&amp;sourceid=sugg&amp;sugoq=&amp;sugn=0&amp;suguuid=fa153a85-07bb-4afa-bb07-69d3775d9966&amp;sugsuv=AAHV9fA6HwAAAAqRK1G8bQ0A1wA%3D&amp;sugtime=1523158844484</span><br></pre></td></tr></table></figure></li><li><p>关键字字段：keyword（有实际值）</p></li></ul></li></ul><h4 id="3-360-搜索（360好搜）："><a href="#3-360-搜索（360好搜）：" class="headerlink" title="3. 360 搜索（360好搜）："></a>3. 360 搜索（360好搜）：</h4><ul><li><p>PC端：</p><ul><li><p>referer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.so.com/link?m=afEPOwxb%2BqdAts7rzNmmh%2F2cxMIM5669zqvLn1I5nPYjRlp8haa0nn%2FWJfYFNGvfzb4XdzUBb5wCnL2um08mnoi%2Bsge9ZjqTN</span><br></pre></td></tr></table></figure></li><li><p>referer 关键字字段：无</p></li></ul></li><li><p>移动端：</p><ul><li><p>referer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://m.so.com/s?q=51la%E7%BB%9F%E8%AE%A1&amp;src=msearch_next_input&amp;sug_pos=&amp;sug=&amp;srcg=home_next</span><br></pre></td></tr></table></figure></li><li><p>关键字字段：q（有实际值）</p></li></ul></li></ul><h4 id="4-谷歌搜索："><a href="#4-谷歌搜索：" class="headerlink" title="4. 谷歌搜索："></a>4. 谷歌搜索：</h4><ul><li><p>PC端：</p><ul><li><p>referer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.co.jp/（每个国家/地区的域名后缀不同，如 co.jp - 日本，hk - 香港，de - 德国）</span><br></pre></td></tr></table></figure></li><li><p>referer 关键字字段：无</p></li></ul></li><li><p>移动端：</p><ul><li><p>referer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com/</span><br></pre></td></tr></table></figure></li><li><p>关键字字段：无</p></li></ul></li></ul><h4 id="5-神马搜索："><a href="#5-神马搜索：" class="headerlink" title="5. 神马搜索："></a>5. 神马搜索：</h4><ul><li>PC端：无</li><li><p>移动端：</p><ul><li><p>referer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zm12.sm-tc.cn/?src=l4uLj8XQ0IiIiNHKztGTntA%3D&amp;uid=b64442e88b6decc4f6ade0bf131e6af0&amp;hid=0828a13d4a51cd539610a6c5a2e50f36&amp;pos=1&amp;cid=9&amp;time=1523160482592&amp;from=click&amp;restype=1&amp;pagetype=0400000000000004&amp;bu=web&amp;query=51la%E7%BB%9F%E8%AE%A1&amp;mode=&amp;v=1&amp;province=%E5%B9%BF%E4%B8%9C%E7%9C%81&amp;city=%E5%B9%BF%E5%B7%9E%E5%B8%82&amp;uc_param_str=dnntnwvepffrgibijbprsvdsdichei</span><br></pre></td></tr></table></figure></li><li><p>关键字字段：query（有实际值），host 为 zm12.sm-tc.cn</p></li></ul></li></ul><h4 id="6-BingLive（微软Bing搜索）："><a href="#6-BingLive（微软Bing搜索）：" class="headerlink" title="6. BingLive（微软Bing搜索）："></a>6. BingLive（微软Bing搜索）：</h4><ul><li><p>PC端：</p><ul><li><p>referer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bing.com/</span><br></pre></td></tr></table></figure></li><li><p>关键字字段：无</p></li></ul></li><li><p>移动端：</p><ul><li><p>referer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bing.com/</span><br></pre></td></tr></table></figure></li><li><p>关键字字段：无</p></li></ul></li></ul><h4 id="7-有道-网易搜索：目前仅为词典搜索"><a href="#7-有道-网易搜索：目前仅为词典搜索" class="headerlink" title="7. 有道/网易搜索：目前仅为词典搜索"></a>7. 有道/网易搜索：目前仅为词典搜索</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-百度搜索：&quot;&gt;&lt;a href=&quot;#1-百度搜索：&quot; class=&quot;headerlink&quot; title=&quot;1. 百度搜索：&quot;&gt;&lt;/a&gt;1. 百度搜索：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;PC端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;referer：&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
      <category term="互联网" scheme="http://www.dwxu.me/categories/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
    
      <category term="搜索引擎" scheme="http://www.dwxu.me/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.dwxu.me/2018/05/14/Hello-World/"/>
    <id>http://www.dwxu.me/2018/05/14/Hello-World/</id>
    <published>2018-05-14T13:31:51.000Z</published>
    <updated>2018-05-14T15:32:08.106Z</updated>
    
    <content type="html"><![CDATA[<p>你好，世界！</p><p>不客观的说，自己也不算懒，但也不知道拖延了多久，总算是把个人博客的样子给整出来了。</p><p>基于 GitHub + Hexo 搭建，找了一套相对简洁的页面模板，稍微加以改造，便是现在这个样子，还算满意。</p><p>年后转到公司新的部门后，一直比较忙，期间也解决了一些大大小小的问题，在业务和技术方面也算有所收获，也一直想着找机会和时间总结并记录下来，于是乎又想起来久违的个人博客计划，花了两个晚上失落，过程比较顺利。</p><p>那么，之后要花更多的时间和精力，充实博客，充实自己！</p><p>晚安！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你好，世界！&lt;/p&gt;
&lt;p&gt;不客观的说，自己也不算懒，但也不知道拖延了多久，总算是把个人博客的样子给整出来了。&lt;/p&gt;
&lt;p&gt;基于 GitHub + Hexo 搭建，找了一套相对简洁的页面模板，稍微加以改造，便是现在这个样子，还算满意。&lt;/p&gt;
&lt;p&gt;年后转到公司新的部门后
      
    
    </summary>
    
      <category term="日记" scheme="http://www.dwxu.me/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="日记" scheme="http://www.dwxu.me/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
</feed>
